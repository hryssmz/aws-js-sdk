AWSTemplateFormatVersion: "2010-09-09"
Metadata:
  Version: "1.3"

Parameters:
  IsPolicyAttachAllowed:
    Type: String
    Default: "false"
    AllowedValues:
      - "true"
      - "false"
    Description:
      "(Optional) Whether Quicksetup is allowed to attach policies to existing
      Instance profiles."

  HasDeletedBaseline:
    Type: String
    Default: "false"
    AllowedValues:
      - "true"
      - "false"
    Description:
      "(Optional) Whether patch policy contains a deleted custom patch
      baseline."

  QSType:
    Type: String
    AllowedValues:
      - LA
      - TA
      - MA
    Default: TA
    Description:
      "(Required) Specifies the type of target for the Quick Setup configuration:
      local account only (?LA?), some or all organizational units (?TA?), or management
      account only (?MA?)."

  QSConfigurationId:
    Type: String
    Default: ""
    Description: "(Required) The unique identifier of the deployed configuration."

  QSConfigurationName:
    Type: String
    Default: ""
    Description: "(Required) The name of the configuration."

  SelectedPatchBaselines:
    Type: String
    Default: ""
    Description: Stringified JSON content of selected Patch baselines.

  PatchBaselineUseDefault:
    Type: String
    Default: default
    AllowedValues:
      - default
      - custom
    Description:
      Indicates whether all the selected patch baselines are AWS predefined
      baselines.

  ConfigurationOptionsPatchOperation:
    Type: String
    Default: Scan
    AllowedValues:
      - Scan
      - ScanAndInstall
    Description: "(Required) Whether to scan for patches or install patches."

  RateControlErrorThreshold:
    Type: String
    Default: ""
    Description:
      The number of errors that are allowed before the system stops sending
      requests to run the association on additional targets.

  RateControlConcurrency:
    Type: String
    Default: ""
    Description:
      Indicates the maximum number of target nodes where the patching operation
      can run at a time.

  ConfigurationOptionsScanValue:
    Type: String
    Default: cron(0 1 * * ? *)
    Description:
      "(Optional) A cron expression to define a schedule for the Scan operation,
      or a rate expression to define the frequency for the operation."

  ConfigurationOptionsScanNextInterval:
    Type: String
    Default: "false"
    AllowedValues:
      - "true"
      - "false"
    Description:
      Whether or not to run the State Manager scan associations on next
      CRON interval.

  ConfigurationOptionsInstallValue:
    Type: String
    Default: ""
    Description:
      "(Optional) A cron expression to define a schedule for the Install
      operation, or a rate expression to define the frequency for the operation."

  ConfigurationOptionsInstallNextInterval:
    Type: String
    Default: "true"
    AllowedValues:
      - "true"
      - "false"
    Description:
      Whether or not to run the State Manager install associations on next
      CRON interval.

  OutputLogEnableS3:
    Type: String
    Default: "true"
    AllowedValues:
      - "true"
      - "false"
    Description: "(Optional) Whether or not to send output to s3 bucket."

  OutputBucketRegion:
    Type: String
    Default: ""
    Description:
      "(Required) The ID of the Region where the S3 bucket for storing
      command output logs is located."

  OutputS3BucketName:
    Type: String
    Description: The name of the S3 bucket where command output logs are stored.
    AllowedPattern: "^[a-z0-9.-]{0,63}$"
    Default: ""

  OutputS3KeyPrefix:
    Type: String
    Description:
      The directory structure in the S3 bucket where command output logs
      are stored.
    Default: ""

  TargetType:
    Type: String
    Default: InstanceIds
    AllowedValues:
      - Tags
      - InstanceIds
      - ResourceGroups
      - "*"
    Description:
      "(Optional) Indicates the method by which nodes are targeted. Applies
      to configurations for local accounts only."

  TargetInstances:
    Type: String
    Default: "*"
    Description: "(Optional) Specifies the nodes to target when QSType=LA and ScanTargetType=InstanceIds."

  ResourceGroupName:
    Type: String
    Default: ""
    Description:
      "(Optional) Specifies the name of the resource group to target when
      QSType=LA or QSType=TA and ScanTargetType=ResourceGroups."

  RebootOption:
    Type: String
    Default: NoReboot
    AllowedValues:
      - RebootIfNeeded
      - NoReboot
    Description:
      "(Optional) Reboot behavior after a patch Install operation. If you
      choose NoReboot and patches are installed, the node is marked as noncompliant
      until a subsequent reboot and scan."

  TargetTagKey:
    Type: String
    Default: ""
    Description:
      "(Optional) Specifies the tag key that is applied to the nodes being
      targeted when QSType=LA or QSType=TA and ScanTargetType=Tags."

  TargetTagValue:
    Type: String
    Default: ""
    Description:
      "(Optional) Specifies the tag value that is applied to the nodes
      being targeted when QSType=LA or QSType=TA and ScanTargetType=Tags."

  PatchBaselineRegion:
    Type: String
    Default: ""
    Description: "(Required) The region from which Patch Baselines are pulled"

  AccountId:
    Type: String
    Default: ""
    Description:
      "(Required) Account Id that owns the S3 bucket for baseline_overrides.json
      object"

  TargetEntities:
    Type: String
    Default: ENTIRE_ORG
    AllowedValues:
      - ENTIRE_ORG
      - OU
      - LOCAL
    Description: "(Required) Specifies the target entities"

  OUs:
    Type: CommaDelimitedList
    Default: ""
    Description:
      "(Optional) A list of all Organizational Units (OUs) targeted for
      deployment"

  OrgId:
    Type: String
    Default: ""
    Description: "(Optional) Principal Organization Id of the AWS Organization"

Conditions:
  PolicyAttachAllowed:
    Fn::Equals:
      - Ref: IsPolicyAttachAllowed
      - "true"

  IsGlobalRegion:
    Fn::Equals:
      - Ref: AWS::Region
      - Ref: PatchBaselineRegion

  DeployManagementResources:
    Fn::And:
      - Condition: IsGlobalRegion
      - Fn::Equals:
          - Ref: QSType
          - LA

  CreateInstallInstancesAssociation:
    Fn::Equals:
      - Ref: ConfigurationOptionsPatchOperation
      - ScanAndInstall

  EnabledOutputBucketWithPrefix:
    Fn::And:
      - Fn::Equals:
          - Ref: OutputLogEnableS3
          - "true"
      - Fn::Not:
          - Fn::Equals:
              - Ref: OutputS3KeyPrefix
              - ""

  EnabledOutputBucketWithoutPrefix:
    Fn::And:
      - Fn::Equals:
          - Ref: OutputLogEnableS3
          - "true"
      - Fn::Equals:
          - Ref: OutputS3KeyPrefix
          - ""

  IsTagValueNotSpecified:
    Fn::Equals:
      - Ref: TargetTagValue
      - ""

  IsTagKeyAndValueTargeted:
    Fn::And:
      - Fn::Equals:
          - Ref: TargetType
          - Tags
      - Fn::Not:
          - Condition: IsTagValueNotSpecified

  IsTagKeyOnlyTargeted:
    Fn::And:
      - Fn::Equals:
          - Ref: TargetType
          - Tags
      - Condition: IsTagValueNotSpecified

  IsResourceGroupTargeted:
    Fn::Equals:
      - Ref: TargetType
      - ResourceGroups

  TargetAll:
    Fn::Equals:
      - Ref: TargetInstances
      - "*"

Resources:
  BaselineOverridesAccessLogBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName:
        Fn::Join:
          - "-"
          - - Fn::Sub: aws-quicksetup-patchpolicy-access-log-${AccountId}
            - Fn::Select:
                - 3
                - Fn::Split:
                    - "-"
                    - Fn::Select:
                        - 2
                        - Fn::Split:
                            - "/"
                            - Ref: AWS::StackId
            - Ref: QSConfigurationId
      AccessControl: Private
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      LifecycleConfiguration:
        Rules:
          - Id: MoveToGlacierAfter90Days_DeleteAfter10Years
            ExpirationInDays: 3653
            Status: Enabled
            Transitions:
              - StorageClass: GLACIER_IR
                TransitionInDays: 90
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerEnforced
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Enabled
    DeletionPolicy: Retain
    Condition: DeployManagementResources

  BaselineOverridesAccessLogBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket:
        Ref: BaselineOverridesAccessLogBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: DenyInsecureTransport
            Effect: Deny
            Principal: "*"
            Action: s3:*
            Resource:
              - Fn::Sub: arn:${AWS::Partition}:s3:::${BaselineOverridesAccessLogBucket}
              - Fn::Sub: arn:${AWS::Partition}:s3:::${BaselineOverridesAccessLogBucket}/*
            Condition:
              Bool:
                aws:SecureTransport: "false"
          - Sid: S3ServerAccessLogsPolicy
            Effect: Allow
            Principal:
              Service: logging.s3.amazonaws.com
            Action:
              - s3:PutObject
            Resource:
              Fn::Sub: arn:${AWS::Partition}:s3:::${BaselineOverridesAccessLogBucket}/*
            Condition:
              ArnLike:
                aws:SourceArn:
                  Fn::Sub: arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-${AccountId}-${QSConfigurationId}
              StringEquals:
                aws:SourceAccount:
                  Ref: AccountId
    Condition: DeployManagementResources

  BaselineOverridesLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName:
        Fn::Join:
          - "-"
          - - baseline-overrides
            - Fn::Select:
                - 3
                - Fn::Split:
                    - "-"
                    - Fn::Select:
                        - 2
                        - Fn::Split:
                            - "/"
                            - Ref: AWS::StackId
            - Ref: QSConfigurationId
      Description:
        Lambda function that responds to Delete and Create events from
        CloudFormation or performs baseline remediation when triggered by the State
        Manager Association executing the Automation Document
      Code:
        ZipFile: |
          # Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.
          # Licensed under the Apache License, Version 2.0 (the 'License'). You
          # may not use this file except in compliance with the License. A copy of
          # the License is located at
          #     http://aws.amazon.com/apache2.0/
          # or in the 'license' file accompanying this file. This file is
          # distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
          # ANY KIND, either express or implied. See the License for the specific
          # language governing permissions and limitations under the License.
          #
          # This handler performs CRUD operations on an S3 object.
          # This handler also adds a Quick Setup specific bucket policy to the bucket
          # to enable target nodes to pull down the S3 object during patching operations.


          import boto3
          import json
          import urllib3
          import time
          import os


          SUCCESS = 'SUCCESS'
          FAILED = 'FAILED'

          # Events sent in by CloudFormation
          CREATE = 'Create'
          UPDATE = 'Update'
          DELETE = 'Delete'

          # Event sent in by Automation
          REMEDIATE = 'Remediate'

          DEFAULT_REGION = 'us-east-1'

          region = os.environ['REGION']
          s3_client = boto3.client('s3', region_name=region)
          ssm_client = boto3.client('ssm', region_name=region)
          s3_resource = boto3.resource('s3', region_name=region)
          http = urllib3.PoolManager()


          def create_bucket(bucket_name):
              bucket_creation_params = {
                  'ACL': 'private',
                  'Bucket': bucket_name,
                  'CreateBucketConfiguration': {
                      'LocationConstraint': region
                  },
                  'ObjectOwnership': 'BucketOwnerEnforced'
              }

              if region == DEFAULT_REGION:
                  del bucket_creation_params['CreateBucketConfiguration']
                  print('Creating a bucket in', DEFAULT_REGION, '...', '\n')
              else:
                  print('Creating a bucket in', region, '...', '\n')

              s3_client.create_bucket(**bucket_creation_params)
              waiter = s3_client.get_waiter('bucket_exists')
              waiter.wait(Bucket=bucket_name)
              print('Successfully created the bucket:', bucket_name, '\n')


          def put_bucket_versioning(bucket_name):
              print('Enabling bucket versioning... \n')
              s3_client.put_bucket_versioning(
                  Bucket=bucket_name,
                  VersioningConfiguration={
                      'MFADelete': 'Disabled',
                      'Status': 'Enabled'
                  }
              )
              print('Bucket versioning enabled \n')


          def put_bucket_encryption(bucket_name):
              print('Applying server side encryption to the bucket... \n')
              s3_client.put_bucket_encryption(
                  Bucket=bucket_name,
                  ServerSideEncryptionConfiguration={
                      'Rules': [
                          {
                              'ApplyServerSideEncryptionByDefault': {
                                  'SSEAlgorithm': 'AES256'
                              }
                          }
                      ]
                  }
              )
              print('Encryption applied to the bucket \n')


          def put_public_access_block(bucket_name):
              print('Turning on public access block for the bucket... \n')
              s3_client.put_public_access_block(
                  Bucket=bucket_name,
                  PublicAccessBlockConfiguration={
                      'BlockPublicAcls': True,
                      'IgnorePublicAcls': True,
                      'BlockPublicPolicy': True,
                      'RestrictPublicBuckets': True
                  }
              )
              print('Public access block turned on for the bucket \n')


          def put_bucket_lifecycle_configuration(bucket_name):
              print('Applying lifecycle configuration to the bucket... \n')
              s3_client.put_bucket_lifecycle_configuration(
                  Bucket=bucket_name,
                  LifecycleConfiguration={
                      'Rules': [
                          {
                              'ID': 'DeleteVersionsOlderThan90Days',
                              'Filter': {
                                  'Prefix': 'baseline_overrides.json'
                              },
                              'Status': 'Enabled',
                              'NoncurrentVersionExpiration': {
                                  'NoncurrentDays': 90
                              }
                          }
                      ]
                  }
              )
              print('Lifecycle configuration applied to the bucket \n')


          def put_bucket_policy(bucket_name, resource_properties):
              print('Constructing and applying bucket policy... \n')
              partition = resource_properties['Partition']
              baseline_overrides_json = f'arn:{partition}:s3:::{bucket_name}/baseline_overrides.json'
              qs_configuration_id = resource_properties['QSConfigId']
              target_entities = resource_properties['TargetEntities']
              organizational_units = resource_properties['OrgUnits']
              principal_org_id = resource_properties['PrincipalOrgId']
              account_id = resource_properties['AccountId']

              bucket_policy = {
                  'Version': '2012-10-17',
                  'Statement': [
                      {
                          'Sid': 'DenyInsecureTransport',
                          'Effect': 'Deny',
                          'Principal': '*',
                          'Action': 's3:*',
                          'Resource': [
                              f'arn:{partition}:s3:::{bucket_name}/*'
                          ],
                          'Condition': {
                              'Bool': {
                                  'aws:SecureTransport': 'false'
                              }
                          }
                      },
                      {
                          'Sid': 'DenyAllButPrincipalsWithTag',
                          'Effect': 'Deny',
                          'Principal': {
                              'AWS': '*'
                          },
                          'Action': 's3:GetObject',
                          'Resource': [
                              baseline_overrides_json
                          ],
                          'Condition': {
                              'StringNotEquals': {
                                  f'aws:PrincipalTag/QSConfigId-{qs_configuration_id}': f'{qs_configuration_id}'
                              }
                          }
                      }
                  ]
              }

              target_statement = {
                  'Sid': 'Target',
                  'Effect': 'Allow',
                  'Action': 's3:GetObject',
                  'Resource': baseline_overrides_json
              }

              if target_entities.upper() == 'OU':
                  if len(organizational_units) == 0:
                      raise ValueError('Was expecting at least one OU')

                  principal_org_paths = [
                      f'{principal_org_id}/*/{ou}/*' for ou in organizational_units if ou.startswith('ou-')]

                  if len(principal_org_paths) == 0:
                      raise ValueError('Was expecting at least one OU')

                  target_statement['Principal'] = '*'
                  target_statement['Condition'] = {
                      'ForAnyValue:StringLike': {
                          'aws:PrincipalOrgPaths': principal_org_paths
                      }
                  }
              elif target_entities.upper() == 'ENTIRE_ORG':
                  target_statement['Principal'] = '*'
                  target_statement['Condition'] = {
                      'StringEquals': {
                          'aws:PrincipalOrgID': [
                              f'{principal_org_id}'
                          ]
                      }
                  }
              elif target_entities.upper() == 'LOCAL':
                  target_statement['Principal'] = {"AWS": account_id}
              else:
                  raise ValueError(
                      'Got an unexpected value for target entities; was expecting ENTIRE_ORG, LOCAL, or OU')

              bucket_policy['Statement'].append(target_statement)

              s3_client.put_bucket_policy(
                  Bucket=bucket_name,
                  Policy=json.dumps(bucket_policy)
              )
              print('Bucket policy applied \n')


          def put_bucket_logging(bucket_name, access_log_bucket_name):
              print('Enabling logging for the bucket... \n')
              s3_client.put_bucket_logging(
                  Bucket=bucket_name,
                  BucketLoggingStatus={
                      'LoggingEnabled': {
                          'TargetBucket': access_log_bucket_name,
                          'TargetPrefix': ''
                      }
                  }
              )
              print('Logging enabled for the bucket \n')


          def get_patch_baselines(patch_baseline_ids, request_type) -> dict:
              print('Retrieving patch baselines... \n')
              patch_baselines = []
              non_existent_baseline_ids = []

              if request_type in (CREATE, UPDATE):
                  try:
                      for baseline_id in patch_baseline_ids:
                          baseline = ssm_client.get_patch_baseline(
                              BaselineId=baseline_id
                          )
                          patch_baselines.append(baseline)

                      print('Patch baselines retrieved \n')
                      return {
                          'PatchBaselines': json.dumps(patch_baselines, default=str),
                          'NonExistentBaselineIds': non_existent_baseline_ids
                      }
                  except ssm_client.exceptions.DoesNotExistException as err:
                      print(f'Baseline id {baseline_id} does not exist')
                      print(err, '\n')
                      raise err

              elif request_type == REMEDIATE:  # Different behavior for Remediate by design
                  for baseline_id in patch_baseline_ids:
                      try:
                          baseline = ssm_client.get_patch_baseline(
                              BaselineId=baseline_id
                          )
                          patch_baselines.append(baseline)
                      except ssm_client.exceptions.DoesNotExistException:
                          non_existent_baseline_ids.append(baseline_id)

                  print('Patch baselines retrieved \n')
                  return {
                      'PatchBaselines': json.dumps(patch_baselines, default=str),
                      'NonExistentBaselineIds': non_existent_baseline_ids
                  }


          def place_baselines_into_bucket(bucket_name, baselines):
              print('Loading the baselines... \n')
              s3_client.put_object(
                  Body=baselines['PatchBaselines'],
                  Bucket=bucket_name,
                  Key='baseline_overrides.json',
              )
              print('Baselines loaded \n')

              if baselines['NonExistentBaselineIds']:
                  print('The following baseline ids could not be found:',
                        baselines['NonExistentBaselineIds'], '\n')
                  raise ValueError(
                      f'The following baseline ids could not be found: {baselines["NonExistentBaselineIds"]}')


          def permanently_delete_all_objects(bucket_name):
              print('Deleting all objects in the bucket permanently... \n')
              bucket = s3_resource.Bucket(bucket_name)
              bucket.object_versions.all().delete()
              time.sleep(2)
              print('Bucket has been emptied \n')


          def delete_bucket(bucket_name):
              print('Deleting the bucket... \n')
              s3_client.delete_bucket(
                  Bucket=bucket_name
              )
              waiter = s3_client.get_waiter('bucket_not_exists')
              waiter.wait(
                  Bucket=bucket_name
              )
              print('Bucket deleted successfully \n')


          def empty_and_delete_bucket(bucket_name):
              try:
                  s3_client.head_bucket(
                      Bucket=bucket_name
                  )
                  permanently_delete_all_objects(bucket_name)
                  delete_bucket(bucket_name)
              except Exception as err:
                  # Bucket does not exist or is not owned by the account
                  if err.response['Error']['Code'] == '404':
                      return
                  else:
                      raise err


          def send(event, context, responseStatus, responseData=None, physicalResourceId=None, noEcho=False, reason=None):
              request_type = event.get('RequestType')
              if not request_type in (CREATE, UPDATE, DELETE):
                  return

              print('Preparing response to CloudFormation... \n')

              responseUrl = event['ResponseURL']
              responseBody = {
                  'Status': responseStatus,
                  'Reason': reason or f'See the details in CloudWatch Log Stream: {context.log_stream_name}',
                  'PhysicalResourceId': physicalResourceId or context.log_stream_name,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'NoEcho': noEcho,
                  'Data': responseData
              }

              print('Response body:', responseBody, '\n')
              json_responseBody = json.dumps(responseBody)

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_responseBody))
              }

              try:
                  print('Sending response to CloudFormation via http request... \n')
                  response = http.request(
                      'PUT', responseUrl, headers=headers, body=json_responseBody, retries=5)
                  print('Status code:', response.status, '\n')

              # If this actually happens, the stack could get stuck for an hour
              # waiting for a response from this custom resource.
              # There is a manual way to send a response using curl
              except Exception as err:
                  print('Send failed executing http.request:')
                  print(err, '\n')
                  raise err


          def lambda_handler(event, context):
              request_type = event.get('RequestType')

              # In case of Remediate, ResourceProperties only has BucketName and PatchBaselineIds
              resource_properties = event['ResourceProperties']

              bucket_name = resource_properties['BucketName']
              patch_baseline_ids = [baseline.get('value') for baseline in json.loads(resource_properties['PatchBaselines']).values()]
              access_log_bucket_name = resource_properties.get('AccessLogBucketName')

              print('Event:', event, '\n')

              try:
                  if request_type == CREATE:
                      create_bucket(bucket_name)
                      put_bucket_versioning(bucket_name)
                      put_bucket_encryption(bucket_name)
                      put_public_access_block(bucket_name)
                      put_bucket_lifecycle_configuration(bucket_name)
                      put_bucket_policy(bucket_name, resource_properties)
                      put_bucket_logging(bucket_name, access_log_bucket_name)
                      place_baselines_into_bucket(
                          bucket_name, get_patch_baselines(patch_baseline_ids, request_type))
                      send(event, context, SUCCESS, physicalResourceId=bucket_name)

                  elif request_type == UPDATE:
                      # We are making an assumption that Update event will never cause creation of another bucket.
                      # Bucket name is dynamically constructed using AccountId and QSConfigId
                      put_bucket_policy(bucket_name, resource_properties)
                      place_baselines_into_bucket(
                          bucket_name, get_patch_baselines(patch_baseline_ids, request_type))
                      send(event, context, SUCCESS, physicalResourceId=bucket_name)

                  elif request_type == DELETE:
                      empty_and_delete_bucket(bucket_name)
                      send(event, context, SUCCESS, physicalResourceId=bucket_name)

                  elif request_type == REMEDIATE:
                      print('Starting remediation... \n')
                      place_baselines_into_bucket(
                          bucket_name, get_patch_baselines(patch_baseline_ids, request_type))
                      print('Remediation completed \n')

                  else:
                      print('Unexpected request type received:', request_type)
                      raise ValueError(
                          'A valid RequestType is Create, Update, Delete, or Remediate')

                  return SUCCESS
              except Exception as err:
                  print(err, '\n')
                  print('You can review the log for the Lambda function for details \n')
                  send(event, context, FAILED, reason=str(err), physicalResourceId=bucket_name)
                  raise err  # To send signal to Automation Document of failure
      Runtime: python3.9
      Handler: index.lambda_handler
      Environment:
        Variables:
          REGION:
            Ref: PatchBaselineRegion
      MemorySize: 128
      Role:
        Fn::GetAtt:
          - BaselineOverridesLambdaRole
          - Arn
      Timeout: 300
    Condition: DeployManagementResources

  BaselineOverridesLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Join:
          - "-"
          - - "/aws/lambda/baseline-overrides"
            - Fn::Select:
                - 3
                - Fn::Split:
                    - "-"
                    - Fn::Select:
                        - 2
                        - Fn::Split:
                            - "/"
                            - Ref: AWS::StackId
            - Ref: QSConfigurationId
      RetentionInDays: 3653
    DeletionPolicy: Retain
    Condition: DeployManagementResources

  BaselineOverridesLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName:
        Fn::Sub: AWS-QuickSetup-BaselineOverrides-LambdaRole-${QSConfigurationId}
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName:
            Fn::Sub: AWS-QuickSetup-BaselineOverrides-LambdaPolicy-${QSConfigurationId}
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: AllowS3Actions
                Effect: Allow
                Action:
                  - s3:CreateBucket
                  - s3:PutBucketVersioning
                  - s3:PutBucketOwnershipControls
                  - s3:PutBucketPublicAccessBlock
                  - s3:PutEncryptionConfiguration
                  - s3:GetObject
                  - s3:PutBucketPolicy
                  - s3:GetObjectVersion
                  - s3:PutObject
                  - s3:DeleteObject
                  - s3:ListBucketVersions
                  - s3:DeleteObjectVersion
                  - s3:DeleteBucket
                  - s3:PutLifecycleConfiguration
                  - s3:ListBucket
                  - s3:PutBucketLogging
                Resource:
                  - Fn::Sub: arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-${AccountId}-${QSConfigurationId}/*
                  - Fn::Sub: arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-${AccountId}-${QSConfigurationId}
              - Sid: AllowLogging
                Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - Fn::Join:
                      - ""
                      - - Fn::Sub: arn:${AWS::Partition}:logs:${AWS::Region}:${AccountId}:log-group:/aws/lambda/baseline-overrides-
                        - Fn::Select:
                            - 3
                            - Fn::Split:
                                - "-"
                                - Fn::Select:
                                    - 2
                                    - Fn::Split:
                                        - "/"
                                        - Ref: AWS::StackId
                        - "-"
                        - Ref: QSConfigurationId
                        - ":*"
              - Sid: AllowSSMActions
                Action:
                  - ssm:GetPatchBaseline
                Effect: Allow
                Resource: "*"
    Condition: DeployManagementResources

  BaselineOverridesLambdaTrigger:
    Type: Custom::S3Object
    Properties:
      ServiceToken:
        Fn::GetAtt:
          - BaselineOverridesLambdaFunction
          - Arn
      AccountId:
        Ref: AccountId
      QSConfigId:
        Ref: QSConfigurationId
      BucketName:
        Fn::Sub: aws-quicksetup-patchpolicy-${AccountId}-${QSConfigurationId}
      AccessLogBucketName:
        Ref: BaselineOverridesAccessLogBucket
      Partition:
        Ref: AWS::Partition
      TargetEntities:
        Ref: TargetEntities
      OrgUnits:
        Ref: OUs
      PrincipalOrgId:
        Ref: OrgId
      PatchBaselines:
        Ref: SelectedPatchBaselines
    Condition: DeployManagementResources

  BaselineOverridesStateManagerAssociation:
    Type: AWS::SSM::Association
    Properties:
      AssociationName:
        Fn::Sub: AWS-QuickSetup-PatchPolicy-BaselineRemediation-${QSConfigurationId}
      Name:
        Ref: BaselineOverridesRemediationAutomationDocument
      ApplyOnlyAtCronInterval: true
      ScheduleExpression: cron(0 0/1 * * ? *)
    Condition: DeployManagementResources

  BaselineOverridesRemediationAutomationDocument:
    Type: AWS::SSM::Document
    Properties:
      Name:
        Fn::Sub: QuickSetup-Remediation-AutomationDocument-${QSConfigurationId}
      DocumentType: Automation
      UpdateMethod: NewVersion
      Content:
        description:
          This Document is to trigger the Lambda function to perform remediation
          only.
        schemaVersion: "0.3"
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          AutomationAssumeRole:
            type: String
            default:
              Fn::GetAtt:
                - BaselineOverridesRemediationAutomationRole
                - Arn
          LambdaFunctionArn:
            type: String
            default:
              Fn::GetAtt:
                - BaselineOverridesLambdaFunction
                - Arn
          BucketName:
            type: String
            default:
              Fn::Sub: aws-quicksetup-patchpolicy-${AccountId}-${QSConfigurationId}
          PatchBaselines:
            type: String
            default:
              Ref: SelectedPatchBaselines
        mainSteps:
          - name: invokeBaselineOverridesLambdaFunction
            action: aws:invokeLambdaFunction
            timeoutSeconds: 300
            inputs:
              FunctionName: "{{ LambdaFunctionArn }}"
              InputPayload:
                RequestType: Remediate
                ResourceProperties:
                  BucketName: "{{ BucketName }}"
                  PatchBaselines: "{{ PatchBaselines }}"
    Condition: DeployManagementResources

  BaselineOverridesRemediationAutomationRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName:
        Fn::Sub: AWS-QuickSetup-Remediation-AutomationRole-${QSConfigurationId}
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ssm.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName:
            Fn::Sub: AWS-QuickSetup-Remediation-AutomationPolicy-${QSConfigurationId}
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  Fn::GetAtt:
                    - BaselineOverridesLambdaFunction
                    - Arn
    Condition: DeployManagementResources

  RoleForAutomation:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ssm.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - iam:AttachRolePolicy
                Resource:
                  - Fn::If:
                      - PolicyAttachAllowed
                      - "*"
                      - Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AmazonSSMRoleForInstancesQuickSetup
                Condition:
                  ArnEquals:
                    iam:PolicyARN:
                      - Fn::Sub: arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
                      - Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/ssm/quicksetup/patchpolicy/aws-quicksetup-patchpolicy-baselineoverrides-s3
              - Effect: Allow
                Action:
                  - iam:TagRole
                Resource:
                  - Fn::If:
                      - PolicyAttachAllowed
                      - "*"
                      - Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AmazonSSMRoleForInstancesQuickSetup
                Condition:
                  ForAllValues:StringEquals:
                    aws:TagKeys:
                      Fn::Sub: QSConfigId-${QSConfigurationId}
              - Effect: Deny
                Action:
                  - iam:TagRole
                  - iam:AttachRolePolicy
                Resource:
                  Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AWS-QuickSetup-AutomationRole-*
              - Effect: Allow
                Action:
                  - iam:CreatePolicy
                Resource:
                  Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/ssm/quicksetup/patchpolicy/aws-quicksetup-patchpolicy-baselineoverrides-s3
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource:
                  Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AmazonSSMRoleForInstancesQuickSetup
                Condition:
                  StringEquals:
                    iam:PassedToService:
                      - ec2.amazonaws.com
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource:
                  Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AmazonSSMRoleForInstancesQuickSetup
                Condition:
                  StringEquals:
                    iam:PassedToService:
                      - ssm.amazonaws.com
              - Effect: Allow
                Action:
                  - ec2:AssociateIamInstanceProfile
                Resource: "*"
                Condition:
                  StringEquals:
                    ec2:NewInstanceProfile:
                      Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/AmazonSSMRoleForInstancesQuickSetup
              - Effect: Allow
                Action:
                  - iam:AddRoleToInstanceProfile
                Resource:
                  Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/AmazonSSMRoleForInstancesQuickSetup
              - Effect: Allow
                Action:
                  - iam:CreateRole
                  - iam:GetRole
                Resource:
                  Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AmazonSSMRoleForInstancesQuickSetup
              - Effect: Allow
                Action:
                  - iam:CreateInstanceProfile
                Resource:
                  Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:instance-profile/AmazonSSMRoleForInstancesQuickSetup
              - Effect: Allow
                Action:
                  - ec2:DescribeIamInstanceProfileAssociations
                  - ec2:DescribeInstances
                  - iam:GetInstanceProfile
                  - iam:ListInstanceProfilesForRole
                  - ssm:DescribeInstanceInformation
                  - ssm:UpdateManagedInstanceRole
                  - ssm:GetAutomationExecution
                  - ssm:StartAutomationExecution
                Resource: "*"
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource:
                  Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AWS-QuickSetup-AutomationRole-${AWS::Region}-${QSConfigurationId}
                Condition:
                  StringEquals:
                    iam:PassedToService:
                      - ssm.amazonaws.com
          PolicyName:
            Fn::Sub: AWS-QuickSetup-AutomationPolicy-IAM-${AWS::Region}-${QSConfigurationId}
        - PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - ssm:RemoveTagsFromResource
                  - ssm:GetInventory
                  - ssm:AddTagsToResource
                Resource: "*"
          PolicyName:
            Fn::Sub: AWS-QuickSetup-AutomationPolicy-NameTagRemediation-${AWS::Region}-${QSConfigurationId}
        - PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - ec2:CreateTags
                  - ec2:DeleteTags
                Resource: "*"
                Condition:
                  ForAllValues:StringEquals:
                    aws:TagKeys:
                      Fn::Sub: QSConfigName-${QSConfigurationId}
          PolicyName:
            Fn::Sub: AWS-QuickSetup-AutomationPolicy-AddRemoveNameTag-${AWS::Region}-${QSConfigurationId}
      RoleName:
        Fn::Sub: AWS-QuickSetup-AutomationRole-${AWS::Region}-${QSConfigurationId}
    DependsOn:
      - CreateAndAttachIAMToEc2InstanceDocument
      - AddRemoveNameTagAutomationDocument
      - NameTagRemediationDocument

  EnableExplorerRoleForPatchPolicy:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ssm.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - iam:ListRoles
                  - config:DescribeConfigurationRecorders
                  - compute-optimizer:GetEnrollmentStatus
                  - support:DescribeTrustedAdvisorChecks
                Resource: "*"
              - Effect: Allow
                Action:
                  - ssm:UpdateServiceSetting
                  - ssm:GetServiceSetting
                Resource:
                  - Fn::Sub: arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsitem/ssm-patchmanager
                  - Fn::Sub: arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsitem/EC2
                  - Fn::Sub: arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/ExplorerOnboarded
                  - Fn::Sub: arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/Association
                  - Fn::Sub: arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/ComputeOptimizer
                  - Fn::Sub: arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/ConfigCompliance
                  - Fn::Sub: arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/OpsData-TrustedAdvisor
                  - Fn::Sub: arn:${AWS::Partition}:ssm:*:*:servicesetting/ssm/opsdata/SupportCenterCase
              - Effect: Allow
                Action:
                  - iam:CreateServiceLinkedRole
                Resource:
                  Fn::Sub: arn:${AWS::Partition}:iam::*:role/aws-service-role/ssm.${AWS::URLSuffix}/AWSServiceRoleForAmazonSSM
                Condition:
                  StringEquals:
                    iam:AWSServiceName: ssm.amazonaws.com
          PolicyName: SSMQuickSetupEnableExplorerInlinePolicy
      RoleName:
        Fn::Sub: AWS-QuickSetup-EnableExplorer-${AWS::Region}-${QSConfigurationId}

  QuickSetupEnableExplorerAssociation:
    Type: AWS::SSM::Association
    Properties:
      Name: AWS-EnableExplorer
      AssociationName:
        Fn::Sub: AWS-QuickSetup-PatchPolicy-EnableExplorer-${QSConfigurationId}
      Parameters:
        AutomationAssumeRole:
          - Fn::GetAtt:
              - EnableExplorerRoleForPatchPolicy
              - Arn

  NameTagDeleteLambda:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          # Copyright 2022 Amazon.com, Inc. or its affiliates. All Rights Reserved.

          # This handler responds to a Cloud Formation Stack 'DELETE' notification.
          # It is responsible for detaching all name tags from target nodes, including
          # nodes that are no longer a target of the Quick Setup Configuration but for which
          # drift has not yet been remediated.
          from asyncore import poll
          from botocore.exceptions import ClientError
          import boto3
          import json
          from urllib.request import build_opener, HTTPHandler, Request
          import os
          import time

          # ENVIRONMENT VARIABLES
          region = os.environ["REGION"]

          # CONSTANTS
          MINUTES_FOR_POLLING_COMPLETION = 600  # 10 hrs max.
          ASSOCIATION_NON_TERMINAL_STATUSES = ["Pending", "InProgress"]
          DESCRIBE_ASSOCIATION_KEYS = [
              "AssociationId",
              "Parameters",
              "DocumentVersion",
              "ScheduleExpression",
              "OutputLocation",
              "Name",
              "Targets",
              "AssociationName",
              "AssociationVersion",
              "AutomationTargetParameterName",
              "MaxErrors",
              "MaxConcurrency",
              "ComplianceSeverity",
              "SyncCompliance",
              "ApplyOnlyAtCronInterval",
              "CalendarNames",
              "TargetLocations",
          ]

          # CLIENTS
          client = boto3.client("ssm", region_name=region)


          def build_request(event, status, message):
              try:
                  stack_id = check_for_key(event, "StackId")
                  request_id = check_for_key(event, "RequestId")
                  logical_resource_id = check_for_key(event, "LogicalResourceId")

                  body = json.dumps(
                      {
                          "Status": status,
                          "Reason": message,
                          "StackId": stack_id,
                          "RequestId": request_id,
                          "LogicalResourceId": logical_resource_id,
                          "PhysicalResourceId": "associationId",
                      }
                  )

                  request = Request(
                      check_for_key(event, "ResponseURL"), data=body.encode("utf-8")
                  )

                  request.add_header("Content-Type", "")
                  request.add_header("Content-Length", len(body.encode("utf-8")))
                  request.get_method = lambda: "PUT"

                  return request
              except Exception as ex:
                  raise Exception(
                      "An Exception occurred while building a response for Cloud Formation. %s"
                      % (str(ex))
                  )


          def poll_for_association_completion(event, association_ids):
              for id in association_ids:
                  counter = 0
                  while True:
                      print("Polling for Association completion: %s" % (id))
                      response = client.describe_association_executions(AssociationId=id)

                      print("DescribeAssociationExecution result: %s" % (str(response)))

                      ## check status, exit if good
                      executions = response["AssociationExecutions"]

                      if len(executions) < 1:
                          msg = (
                              "Association %s has never been executed. Something went wrong. "
                              % (id)
                          )
                          send_response(event, "FAILED", msg)
                          return False
                      else:
                          status = executions[0]["Status"]
                          print(
                              "Found status of %s for latest execution of %s"
                              % (status, id)
                          )
                          # Association Execution History is always reported in descending order.
                          if status in ASSOCIATION_NON_TERMINAL_STATUSES:
                              print(
                                  "Association %s is %s . Waiting 5 seconds. "
                                  % (id, executions[0]["Status"])
                              )
                              time.sleep(5)

                              counter += 1

                              if counter == MINUTES_FOR_POLLING_COMPLETION:
                                  msg = "Association has not finished in the required time. Exiting."
                                  send_response(event, "FAILED", msg)
                                  return False
                          else:
                              # if the status is not success, fail the Lambda.
                              if status.lower() != "success":
                                  msg = (
                                      "Association %s returned a non-success status of %s."
                                      % (id, status)
                                  )
                                  send_response(event, "FAILED", msg)
                                  return False
                              else:
                                  print("Association %s completed successfully." % (id))

                                  return True


          def build_opener_and_open(request):
              opener = build_opener(HTTPHandler)
              response = opener.open(request)

              return response


          def send_response(event, status, message, count=0):
              try:
                  request = build_request(event, status, message)

                  response = build_opener_and_open(request)
                  # This snippet is the reason behind not using the cfnresponse python module
                  # found here: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cfn-lambda-function-code-cfnresponsemodule.html

                  # The cfnresponse python module simply print's an http status code error and succeeds.
                  # The desired behavior is for the Lambda to fail if the response code is not 200.
                  # technically, this response status should be a string but the urllib library doesn't say
                  # if it is translated to a string or not.
                  if str(response.status) != "200":
                      raise Exception(
                          "Received a failed response from Cloud Formation: %s"
                          % (str(response.status))
                      )
              except Exception as ex:
                  print(
                      "An Exception occured while sending a response to Cloud Formation."
                  )
                  if count < 3:
                      count += 1
                      send_response(event, status, message, count)
                  else:
                      raise Exception("Retries failed. Failing Lambda execution.")


          def check_for_key(hash, key):
              if not key in hash:
                  raise Exception(
                      "The required key %s is not present in %s. Failing."
                      % (key, str(hash))
                  )
              else:
                  # return the value
                  return hash[key]


          def update_association(event, association_id):
              print("Describing association %s for update command." % (association_id))

              response = client.describe_association(AssociationId=association_id)

              print(response)

              association = response["AssociationDescription"]

              print("Using Association Overview %s: " % (str(association)))
              print(
                  "Stripping described association of keys that cannot be used in update command."
              )

              keys_to_pop = []
              [
                  keys_to_pop.append(key)
                  if key not in DESCRIBE_ASSOCIATION_KEYS
                  else print(key)
                  for key in association
              ]
              [association.pop(key) for key in keys_to_pop]

              # Postfix name with -delete for easy identification.

              association["AssociationName"] = association["AssociationName"] + "-DELETE"

              # TAG DOCUMENT
              if "TagAction" in association["Parameters"]:
                  association["AutomationTargetParameterName"] = "InstanceId"

                  association["Targets"] = association["Targets"]
                  association["Parameters"]["TagAction"] = ["Remove"]
              else:
                  # REMEDIATION DOCUMENT
                  # Remediation document uses the NoOp Automation target tag which State Manager does not

                  # comprehend as a parameter and only adds if the following parameters are not present.
                  if "Targets" in association:
                      association.pop("Targets")

              print("Attempting to update association %s" % (association))
              response = client.update_association(**association)
              print("UpdateResponse: %s" % (str(response)))


          def handler(event, context):
              try:
                  print("Received event %s" % (str(event)))

                  request = None
                  request = check_for_key(event, "RequestType")

                  if request == None or request.lower() != "delete":
                      msg = (
                          "Received a %s request. Tag Detach Machine only handles CF Stack 'Delete' events. Succeeding."
                          % (str(request))
                      )
                      send_response(event, "SUCCESS", msg)
                      return

                  resource_properties = check_for_key(event, "ResourceProperties")

                  tag_association_id = check_for_key(
                      resource_properties, "TagAssociationId"
                  )
                  remediation_association_id = check_for_key(
                      resource_properties, "RemediationAssociationId"
                  )

                  # Now update the associations to have the names postfixed with DELETE and trigger a name tag delete.
                  update_association(event, tag_association_id)
                  update_association(event, remediation_association_id)

                  # Giving Association time to update and trigger new executions.

                  print(
                      "Sleeping to give Association time to update: %s" % (time.ctime())
                  )

                  time.sleep(15)
                  print("Done sleeping: %s" % (time.ctime()))

                  # Now poll for the associations to finish
                  success = poll_for_association_completion(
                      event, [tag_association_id, remediation_association_id]
                  )

                  if success == True:
                      # Once the associations have finished.
                      send_response(
                          event,
                          "SUCCESS",
                          "Association's successfully completed. Exiting Lambda.",
                      )

                  else:
                      msg = "Name tags failed to delete. Retaining resources so customer can trigger a delete after the fact."
                      send_response(event, "FAILED", "%s:" % (msg))

              except Exception as e:
                  send_response(event, "FAILED", "%s:" % (str(e)))
                  raise (e)
      Timeout: 900
      Description:
        Lambda for handling CF 'Delete' events to remove the name tags
        from resources.
      Runtime: python3.9
      Role:
        Fn::GetAtt:
          - RoleForLambdaNameTagDelete
          - Arn
      FunctionName:
        Fn::Join:
          - "-"
          - - Fn::Sub: delete-name-tags-${AWS::Region}
            - Fn::Select:
                - 3
                - Fn::Split:
                    - "-"
                    - Fn::Select:
                        - 2
                        - Fn::Split:
                            - "/"
                            - Ref: AWS::StackId
            - Ref: QSConfigurationId
      Handler: index.handler
      Environment:
        Variables:
          REGION:
            Ref: AWS::Region
    DependsOn:
      - RoleForLambdaNameTagDelete

  RoleForLambdaNameTagDelete:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - ssm:DescribeAssociationExecutions
                  - ssm:UpdateAssociation
                  - ssm:DescribeAssociation
                Resource:
                  - "*"
          PolicyName:
            Fn::Sub: AWS-QuickSetup-LambdaPolicy-NameTagDelete-${AWS::Region}-${QSConfigurationId}
        - PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - iam:PassRole
                Resource:
                  - Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:role/AWS-QuickSetup-AutomationRole-${AWS::Region}-${QSConfigurationId}
          PolicyName:
            Fn::Sub: AWS-QuickSetup-LambdaPolicy-PassRole-${AWS::Region}-${QSConfigurationId}
      ManagedPolicyArns:
        - Fn::Sub: arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      RoleName:
        Fn::Sub: AWS-QuickSetup-PatchPolicy-RoleForLambda-NT-${AWS::Region}-${QSConfigurationId}

  NameTagDeleteMachine:
    Type: Custom::NameTagDeleteMachine
    Version: "1.0"
    Properties:
      ServiceToken:
        Fn::GetAtt:
          - NameTagDeleteLambda
          - Arn
      AutomationAssumeRole:
        Fn::GetAtt:
          - RoleForAutomation
          - Arn
      RemediationAssociationId:
        Fn::GetAtt: SystemAssociationForNameTagRemediation.AssociationId
      TagAssociationId:
        Fn::GetAtt: SystemAssociationForAddRemoveNameTag.AssociationId
    DependsOn:
      - RoleForAutomation
      - NameTagDeleteLambda
      - RoleForLambdaNameTagDelete
      - SystemAssociationForAddRemoveNameTag
      - SystemAssociationForNameTagRemediation

  NameTagDeleteLambdaLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName:
        Fn::Join:
          - "-"
          - - Fn::Sub: "/aws/lambda/delete-name-tags-${AWS::Region}"
            - Fn::Select:
                - 3
                - Fn::Split:
                    - "-"
                    - Fn::Select:
                        - 2
                        - Fn::Split:
                            - "/"
                            - Ref: AWS::StackId
            - Ref: QSConfigurationId
      RetentionInDays: 3653
    DeletionPolicy: Retain
    DependsOn: NameTagDeleteLambda

  SystemAssociationForScanningPatches:
    Type: AWS::SSM::Association
    Properties:
      Name: AWS-RunPatchBaseline
      AssociationName:
        Fn::Sub: AWS-QuickSetup-PatchPolicy-ScanForPatches-${QSType}-${QSConfigurationId}
      Parameters:
        Operation:
          - Scan
        BaselineOverride:
          - Fn::Sub: s3://aws-quicksetup-patchpolicy-${AccountId}-${QSConfigurationId}/baseline_overrides.json
        RebootOption:
          - Ref: RebootOption
      ScheduleExpression:
        Ref: ConfigurationOptionsScanValue
      ApplyOnlyAtCronInterval:
        Ref: ConfigurationOptionsScanNextInterval
      SyncCompliance: MANUAL
      Targets:
        Fn::If:
          - IsTagKeyAndValueTargeted
          - - Key:
                Fn::Sub: tag:${TargetTagKey}
              Values:
                - Ref: TargetTagValue
          - Fn::If:
              - IsTagKeyOnlyTargeted
              - - Key: tag-key
                  Values:
                    - Ref: TargetTagKey
              - Fn::If:
                  - IsResourceGroupTargeted
                  - - Key: resource-groups:Name
                      Values:
                        - Ref: ResourceGroupName
                  - Fn::If:
                      - TargetAll
                      - - Key: InstanceIds
                          Values:
                            - "*"
                      - - Key: InstanceIds
                          Values:
                            Fn::Split:
                              - ","
                              - Ref: TargetInstances
      MaxConcurrency:
        Ref: RateControlConcurrency
      MaxErrors:
        Ref: RateControlErrorThreshold
      OutputLocation:
        Fn::If:
          - EnabledOutputBucketWithPrefix
          - S3Location:
              OutputS3BucketName:
                Ref: OutputS3BucketName
              OutputS3KeyPrefix:
                Ref: OutputS3KeyPrefix
              OutputS3Region:
                Ref: OutputBucketRegion
          - Fn::If:
              - EnabledOutputBucketWithoutPrefix
              - S3Location:
                  OutputS3BucketName:
                    Ref: OutputS3BucketName
                  OutputS3Region:
                    Ref: OutputBucketRegion
              - Ref: AWS::NoValue

  SystemAssociationForInstallingPatches:
    Type: AWS::SSM::Association
    Properties:
      Name: AWS-RunPatchBaseline
      AssociationName:
        Fn::Sub: AWS-QuickSetup-PatchPolicy-InstallPatches-${QSType}-${QSConfigurationId}
      Parameters:
        Operation:
          - Install
        BaselineOverride:
          - Fn::Sub: s3://aws-quicksetup-patchpolicy-${AccountId}-${QSConfigurationId}/baseline_overrides.json
        RebootOption:
          - Ref: RebootOption
      ApplyOnlyAtCronInterval:
        Ref: ConfigurationOptionsInstallNextInterval
      ScheduleExpression:
        Ref: ConfigurationOptionsInstallValue
      SyncCompliance: MANUAL
      Targets:
        Fn::If:
          - IsTagKeyAndValueTargeted
          - - Key:
                Fn::Sub: tag:${TargetTagKey}
              Values:
                - Ref: TargetTagValue
          - Fn::If:
              - IsTagKeyOnlyTargeted
              - - Key: tag-key
                  Values:
                    - Ref: TargetTagKey
              - Fn::If:
                  - IsResourceGroupTargeted
                  - - Key: resource-groups:Name
                      Values:
                        - Ref: ResourceGroupName
                  - Fn::If:
                      - TargetAll
                      - - Key: InstanceIds
                          Values:
                            - "*"
                      - - Key: InstanceIds
                          Values:
                            Fn::Split:
                              - ","
                              - Ref: TargetInstances
      MaxConcurrency:
        Ref: RateControlConcurrency
      MaxErrors:
        Ref: RateControlErrorThreshold
      OutputLocation:
        Fn::If:
          - EnabledOutputBucketWithPrefix
          - S3Location:
              OutputS3BucketName:
                Ref: OutputS3BucketName
              OutputS3KeyPrefix:
                Ref: OutputS3KeyPrefix
              OutputS3Region:
                Ref: OutputBucketRegion
          - Fn::If:
              - EnabledOutputBucketWithoutPrefix
              - S3Location:
                  OutputS3BucketName:
                    Ref: OutputS3BucketName
                  OutputS3Region:
                    Ref: OutputBucketRegion
              - Ref: AWS::NoValue
    Condition: CreateInstallInstancesAssociation

  SystemAssociationForEc2IamManagement:
    Type: AWS::SSM::Association
    Properties:
      ScheduleExpression: rate(30 days)
      Name:
        Ref: CreateAndAttachIAMToEc2InstanceDocument
      AssociationName:
        Fn::Sub: AWS-QuickSetup-PatchPolicy-AttachIAMToEc2Instance-${QSConfigurationId}
      Parameters:
        AutomationAssumeRole:
          - Fn::GetAtt:
              - RoleForAutomation
              - Arn
        IsPolicyAttachAllowed:
          - Ref: IsPolicyAttachAllowed
        QSConfigurationId:
          - Ref: QSConfigurationId
        AwsAccountId:
          - Ref: AWS::AccountId
      AutomationTargetParameterName: InstanceId
      Targets:
        Fn::If:
          - IsTagKeyAndValueTargeted
          - - Key:
                Fn::Sub: tag:${TargetTagKey}
              Values:
                - Ref: TargetTagValue
          - Fn::If:
              - IsTagKeyOnlyTargeted
              - - Key: tag-key
                  Values:
                    - Ref: TargetTagKey
              - Fn::If:
                  - IsResourceGroupTargeted
                  - - Key: ResourceGroup
                      Values:
                        - Ref: ResourceGroupName
                  - Fn::If:
                      - TargetAll
                      - - Key: InstanceIds
                          Values:
                            - "*"
                      - - Key: ParameterValues
                          Values:
                            Fn::Split:
                              - ","
                              - Ref: TargetInstances
    DependsOn:
      - CreateAndAttachIAMToEc2InstanceDocument
      - RoleForAutomation

  SystemAssociationForAddRemoveNameTag:
    Type: AWS::SSM::Association
    Properties:
      ScheduleExpression: rate(30 days)
      Name:
        Ref: AddRemoveNameTagAutomationDocument
      AssociationName:
        Fn::Sub: AWS-QuickSetup-PatchPolicy-AddRemoveNameTag-${QSConfigurationId}
      Parameters:
        AutomationAssumeRole:
          - Fn::GetAtt:
              - RoleForAutomation
              - Arn
        QSConfigurationName:
          - Ref: QSConfigurationName
        QSConfigurationId:
          - Ref: QSConfigurationId
        TagAction:
          - Add
      AutomationTargetParameterName: InstanceId
      Targets:
        Fn::If:
          - IsTagKeyAndValueTargeted
          - - Key:
                Fn::Sub: tag:${TargetTagKey}
              Values:
                - Ref: TargetTagValue
          - Fn::If:
              - IsTagKeyOnlyTargeted
              - - Key: tag-key
                  Values:
                    - Ref: TargetTagKey
              - Fn::If:
                  - IsResourceGroupTargeted
                  - - Key: ResourceGroup
                      Values:
                        - Ref: ResourceGroupName
                  - Fn::If:
                      - TargetAll
                      - - Key: InstanceIds
                          Values:
                            - "*"
                      - - Key: ParameterValues
                          Values:
                            Fn::Split:
                              - ","
                              - Ref: TargetInstances
    DependsOn:
      - AddRemoveNameTagAutomationDocument
      - RoleForAutomation

  SystemAssociationForHybridIamManagement:
    Type: AWS::SSM::Association
    Properties:
      ScheduleExpression: rate(30 days)
      Name:
        Ref: CreateAndAttachIAMToHybridInstanceDocument
      AssociationName:
        Fn::Sub: AWS-QuickSetup-PatchPolicy-AttachIAMToHybridInstance-${QSConfigurationId}
      Parameters:
        AutomationAssumeRole:
          - Fn::GetAtt:
              - RoleForAutomation
              - Arn
        IsPolicyAttachAllowed:
          - Ref: IsPolicyAttachAllowed
        QSConfigurationId:
          - Ref: QSConfigurationId
        AwsAccountId:
          - Ref: AWS::AccountId
        Region:
          - Ref: AWS::Region
      AutomationTargetParameterName: InstanceId
      Targets:
        Fn::If:
          - IsTagKeyAndValueTargeted
          - - Key:
                Fn::Sub: tag:${TargetTagKey}
              Values:
                - Ref: TargetTagValue
          - Fn::If:
              - IsTagKeyOnlyTargeted
              - - Key: tag-key
                  Values:
                    - Ref: TargetTagKey
              - Fn::If:
                  - IsResourceGroupTargeted
                  - - Key: ResourceGroup
                      Values:
                        - Ref: ResourceGroupName
                  - Fn::If:
                      - TargetAll
                      - - Key: InstanceIds
                          Values:
                            - "*"
                      - - Key: ParameterValues
                          Values:
                            Fn::Split:
                              - ","
                              - Ref: TargetInstances
    DependsOn: CreateAndAttachIAMToHybridInstanceDocument

  SystemAssociationForNameTagRemediation:
    Type: AWS::SSM::Association
    Properties:
      ScheduleExpression: rate(1 day)
      Name:
        Ref: NameTagRemediationDocument
      AssociationName:
        Fn::Sub: AWS-QuickSetup-PatchPolicy-NameTagRemediation-${QSConfigurationId}
      Parameters:
        AutomationAssumeRole:
          - Fn::GetAtt:
              - RoleForAutomation
              - Arn
        TargetType:
          - Ref: TargetType
        NameKey:
          - Fn::Sub: QSConfigName-${QSConfigurationId}
        NameValue:
          - Ref: QSConfigurationName
        TargetValues:
          - Fn::If:
              - IsTagKeyAndValueTargeted
              - Fn::Join:
                  - ""
                  - - '{"Key":"'
                    - Fn::Sub: "${TargetTagKey}"
                    - '",'
                    - '"Value":"'
                    - Ref: TargetTagValue
                    - '"}'
              - Fn::If:
                  - IsTagKeyOnlyTargeted
                  - Fn::Join:
                      - ""
                      - - '{"Key":"'
                        - Ref: TargetTagKey
                        - '"}'
                  - Fn::If:
                      - IsResourceGroupTargeted
                      - Fn::Join:
                          - ""
                          - - '{"Key":"'
                            - Ref: ResourceGroupName
                            - '"}'
                      - Fn::If:
                          - TargetAll
                          - '{"Key":"*"}'
                          - Fn::Join:
                              - ""
                              - - '{"Key":"'
                                - Ref: TargetInstances
                                - '"}'
        Region:
          - Fn::Sub: "${AWS::Region}"
    DependsOn:
      - NameTagRemediationDocument
      - RoleForAutomation

  CreateAndAttachIAMToEc2InstanceDocument:
    Type: AWS::SSM::Document
    Properties:
      Content:
        description:
          Composite document for Quick Setup Managing Instances association.
          This document ensures IAM role for instance profile is created in account
          with all required policies
        schemaVersion: "0.3"
        assumeRole: "{{AutomationAssumeRole}}"
        parameters:
          AutomationAssumeRole:
            type: String
          InstanceId:
            type: String
          IsPolicyAttachAllowed:
            type: String
          AwsAccountId:
            type: String
          QSConfigurationId:
            type: String
        mainSteps:
          - name: branchOnInstanceType
            action: aws:branch
            inputs:
              Choices:
                - NextStep: getExistingRoleName
                  Variable: "{{InstanceId}}"
                  StartsWith: i-
            isEnd: true
          - name: getExistingRoleName
            action: aws:executeScript
            inputs:
              Runtime: python3.8
              Handler: getInstanceProfileName
              InputPayload:
                InstanceId: "{{InstanceId}}"
              Script: |-
                import boto3

                def getInstanceProfileName(events, context):
                    ec2_client = boto3.client("ec2")
                    response = ec2_client.describe_instances(InstanceIds=[events["InstanceId"]])
                    if 'IamInstanceProfile' in response['Reservations'][0]['Instances'][0]:
                        return {'RoleName': response['Reservations'][0]['Instances'][0]['IamInstanceProfile']['Arn'].split('instance-profile/')[1]}
                    return {'RoleName': 'NoRoleFound'}
            outputs:
              - Name: existingInstanceProfileRoleName
                Selector: "$.Payload.RoleName"
                Type: String
            nextStep: branchIfProfileExists
          - name: branchIfProfileExists
            action: aws:branch
            inputs:
              Choices:
                - NextStep: createRoleIfNotExists
                  Variable: "{{getExistingRoleName.existingInstanceProfileRoleName}}"
                  StringEquals: NoRoleFound
              Default: checkIfPolicyAttachAllowed
          - name: checkIfPolicyAttachAllowed
            action: aws:branch
            inputs:
              Choices:
                - NextStep: getRoleFromInstanceProfile
                  Variable: "{{IsPolicyAttachAllowed}}"
                  StringEquals: "true"
              Default: createRoleIfNotExists
          - name: getRoleFromInstanceProfile
            action: aws:executeAwsApi
            inputs:
              Service: iam
              Api: GetInstanceProfile
              InstanceProfileName: "{{getExistingRoleName.existingInstanceProfileRoleName}}"
            outputs:
              - Name: existingRoleName
                Selector: "$.InstanceProfile.Roles[0].RoleName"
                Type: String
            nextStep: createBaselineOverridePolicyForExistingRole
          - name: createBaselineOverridePolicyForExistingRole
            action: aws:executeScript
            inputs:
              Runtime: python3.8
              Handler: createBaselineOverridePolicy
              InputPayload:
                PolicyDocument:
                  Fn::Sub:
                    '{"Version": "2012-10-17","Statement": [{"Effect": "Allow","Action":
                    "s3:GetObject","Resource": "arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-*"}]}'
                Path: "/ssm/quicksetup/patchpolicy/"
                PolicyName: aws-quicksetup-patchpolicy-baselineoverrides-s3
              Script:
                "import boto3\nfrom botocore.exceptions import ClientError\niam_client
                = boto3.client('iam')            \ndef createBaselineOverridePolicy(events,
                context):\n    try:\n        policy_name = events['PolicyName']\n        iam_client.create_policy(PolicyName=policy_name,PolicyDocument=events['PolicyDocument'],Path=events['Path'])\n
                \   except ClientError as e:\n        if e.response['Error']['Code']
                == 'EntityAlreadyExists':\n            print('Policy already exists.
                Skipping creation.')\n        else:\n            raise e"
            onFailure: Abort
            description:
              Create the S3 Bucket Policy. If exception and EntityAlreadyExists,
              continue, else Abort.
            nextStep: attachBaselineOverridePolicyToExistingRole
          - name: attachBaselineOverridePolicyToExistingRole
            action: aws:executeAwsApi
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: "{{getRoleFromInstanceProfile.existingRoleName}}"
              PolicyArn:
                Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/ssm/quicksetup/patchpolicy/aws-quicksetup-patchpolicy-baselineoverrides-s3
            description: Attach required managed policy to Instance Profile role.
            nextStep: attachAmazonSSMManagedInstanceCoreToExistingRole
            onFailure: Abort
          - name: attachAmazonSSMManagedInstanceCoreToExistingRole
            action: aws:executeAwsApi
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: "{{getRoleFromInstanceProfile.existingRoleName}}"
              PolicyArn:
                Fn::Sub: arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
            nextStep: attachTagToExistingRole
          - name: attachTagToExistingRole
            action: aws:executeAwsApi
            inputs:
              Service: iam
              Api: TagRole
              RoleName: "{{getRoleFromInstanceProfile.existingRoleName}}"
              Tags:
                - Key:
                    Fn::Sub: QSConfigId-${QSConfigurationId}
                  Value:
                    Fn::Sub: "${QSConfigurationId}"
            isEnd: true
          - name: createRoleIfNotExists
            action: aws:executeScript
            inputs:
              Runtime: python3.8
              Handler: createRoleIfNotExists
              InputPayload:
                Path: "/"
                RoleName: AmazonSSMRoleForInstancesQuickSetup
                AssumeRolePolicyDocument: '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ec2.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
                Description: EC2 role for SSM for Quick-Setup
              Script:
                "import boto3\nfrom botocore.exceptions import ClientError\niam_client
                = boto3.client('iam')            \ndef createRoleIfNotExists(events,
                context):\n    try:\n        iam_client.create_role(\n            Path=events['Path'],\n
                \           RoleName=events['RoleName'],\n            AssumeRolePolicyDocument=events['AssumeRolePolicyDocument'],\n
                \           Description=events['Description']\n        )\n    except
                ClientError as e:\n        if e.response['Error']['Code'] == 'EntityAlreadyExists':\n
                \           print('Role already exists. Skipping creation.')\n        else:\n
                \           raise e"
            onFailure: Abort
            description:
              Create AmazonSSMRoleForInstancesQuickSetup Role For SSM Quick
              Setup
            nextStep: assertRoleForInstanceProfileExists
          - name: assertRoleForInstanceProfileExists
            action: aws:assertAwsResourceProperty
            inputs:
              Service: iam
              Api: GetRole
              PropertySelector: "$.Role.RoleName"
              DesiredValues:
                - AmazonSSMRoleForInstancesQuickSetup
              RoleName: AmazonSSMRoleForInstancesQuickSetup
            nextStep: createBaselineOverridePolicyForRole
          - name: createBaselineOverridePolicyForRole
            action: aws:executeScript
            inputs:
              Runtime: python3.8
              Handler: createBaselineOverridePolicy
              InputPayload:
                PolicyDocument:
                  Fn::Sub:
                    '{"Version": "2012-10-17","Statement": [{"Effect": "Allow","Action":
                    "s3:GetObject","Resource": "arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-*"}]}'
                Path: "/ssm/quicksetup/patchpolicy/"
                PolicyName: aws-quicksetup-patchpolicy-baselineoverrides-s3
              Script:
                "import boto3\nfrom botocore.exceptions import ClientError\niam_client
                = boto3.client('iam')            \ndef createBaselineOverridePolicy(events,
                context):\n    try:\n        policy_name = events['PolicyName']\n        iam_client.create_policy(PolicyName=policy_name,PolicyDocument=events['PolicyDocument'],Path=events['Path'])\n
                \   except ClientError as e:\n        if e.response['Error']['Code']
                == 'EntityAlreadyExists':\n            print('Policy already exists.
                Skipping creation.')\n        else:\n            raise e"
            onFailure: Abort
            description:
              Create the S3 Bucket Policy. If exception and EntityAlreadyExists,
              continue, else Abort.
            nextStep: attachBaselineOverridePolicyToRole
          - name: attachBaselineOverridePolicyToRole
            action: aws:executeAwsApi
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: AmazonSSMRoleForInstancesQuickSetup
              PolicyArn:
                Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/ssm/quicksetup/patchpolicy/aws-quicksetup-patchpolicy-baselineoverrides-s3
            description: Attach required managed policy to Instance Profile role.
            nextStep: attachTagToRole
            onFailure: Abort
          - name: attachTagToRole
            action: aws:executeAwsApi
            inputs:
              Service: iam
              Api: TagRole
              RoleName: AmazonSSMRoleForInstancesQuickSetup
              Tags:
                - Key:
                    Fn::Sub: QSConfigId-${QSConfigurationId}
                  Value:
                    Fn::Sub: "${QSConfigurationId}"
            nextStep: attachAmazonSSMManagedInstanceCoreToRole
          - name: attachAmazonSSMManagedInstanceCoreToRole
            action: aws:executeAwsApi
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: AmazonSSMRoleForInstancesQuickSetup
              PolicyArn:
                Fn::Sub: arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
            nextStep: executeAttachIAMToInstance
          - name: executeAttachIAMToInstance
            action: aws:executeAutomation
            maxAttempts: 10
            timeoutSeconds: 60
            inputs:
              DocumentName: AWS-AttachIAMToInstance
              RuntimeParameters:
                RoleName: AmazonSSMRoleForInstancesQuickSetup
                ForceReplace: false
                AutomationAssumeRole: "{{ AutomationAssumeRole }}"
                InstanceId: "{{ InstanceId }}"
            isEnd: true
      DocumentType: Automation
      TargetType: "/AWS::EC2::Instance"
      Name:
        Fn::Sub: AWSQuickSetup-CreateAndAttachIAMToEc2Node-${QSConfigurationId}

  NameTagRemediationDocument:
    Type: AWS::SSM::Document
    Properties:
      Content:
        description:
          Composite document for Quick Setup Naming  functionality. This
          document ensures that the appropriate tag is removed from all nodes in an
          account that are no longer a target of a Patch Policy.
        schemaVersion: "0.3"
        assumeRole: "{{AutomationAssumeRole}}"
        parameters:
          AutomationAssumeRole:
            type: String
          TargetType:
            type: String
          NameKey:
            type: String
          NameValue:
            type: String
          TargetValues:
            type: String
          Region:
            type: String
        mainSteps:
          - name: performRemediation
            action: aws:executeScript
            inputs:
              Runtime: python3.8
              Handler: begin_remediation
              InputPayload:
                TargetType: "{{TargetType}}"
                NameKey: "{{NameKey}}"
                NameValue: "{{NameValue}}"
                Targets: "{{TargetValues}}"
                Region: "{{Region}}"
              Script: |
                import os
                import resource
                import boto3
                import time
                import json


                def get_ssm_client(region):
                    return boto3.client("ssm", region_name=region)


                def get_ec2_client(region):
                    return boto3.client("ec2", region_name=region)


                def throw_exception_on_response_code(response):
                    response_code = str(response["ResponseMetadata"]["HTTPStatusCode"])

                    if response_code != "200":
                        raise Exception(
                            "Non-OK Status Code received: %s. Full Response: %s. Failing remediation document"
                            % (response_code, str(response))
                        )


                def remove_tag_from_resources(on_prem_instances, tag_key, region):
                    print(
                        "Removing tags from on prem instances: %s"
                        % (",".join(on_prem_instances))
                    )
                    try:
                        for on_prem_instance in on_prem_instances:
                            response = get_ssm_client(region).remove_tags_from_resource(
                                ResourceType="ManagedInstance",
                                ResourceId=on_prem_instance,
                                TagKeys=[tag_key],
                            )
                            print(response)
                            throw_exception_on_response_code(response)

                            time.sleep(0.05)
                    except Exception as e:
                        print(
                            "Exception occurred removing tag for on prem instance %s: %s"
                            % (on_prem_instance, str(e))
                        )
                        raise (e)


                def delete_tags(ec2_instances, tag_key, tag_value, region):
                    print("Removing tags from ec2 instances: %s" % (",".join(ec2_instances)))

                    try:
                        for i in range(0, len(ec2_instances), 250):
                            response = get_ec2_client(region).delete_tags(
                                DryRun=False,
                                Resources=ec2_instances[i : i + 250],
                                Tags=[{"Key": tag_key, "Value": tag_value}],
                            )

                            throw_exception_on_response_code(response)
                            time.sleep(0.20)

                    except Exception as e:
                        print(
                            "Exception occurred removing tag from EC2 Instance %s: %s"
                            % (", ".join(ec2_instances), str(e))
                        )

                        raise (e)


                def get_inventory(request, region):
                    try:
                        instance_ids = []
                        print("Calling get_inventory with request : \n%s \n\n" % (str(request)))
                        response = get_ssm_client(region).get_inventory(**request)

                        print("\n\n")
                        print(response)
                        throw_exception_on_response_code(response)

                        [instance_ids.append(i["Id"]) for i in response["Entities"]]

                        next_token = None
                        if "NextToken" in response:
                            next_token = response["NextToken"]

                        while next_token:
                            request["NextToken"] = next_token
                            response = get_ssm_client(region).get_inventory(**request)

                            throw_exception_on_response_code(response)

                            [instance_ids.append(i["Id"]) for i in response["Entities"]]

                            time.sleep(0.33)

                            if "NextToken" in response:
                                next_token = response["NextToken"]

                            else:
                                next_token = None

                        return instance_ids
                    except Exception as e:
                        print(
                            "Something went wrong retrieving inventory with request: %s. Exception: %s .\n Failing remediation document. "
                            % (request, str(e))
                        )
                        raise e


                def remove_tags(list_of_instances, tag_key, tag_value, region):
                    mi = []
                    i = []
                    for instance in list_of_instances:
                        if instance.startswith("mi"):
                            mi.append(instance)
                        else:
                            i.append(instance)

                    delete_tags(i, tag_key, tag_value, region)
                    remove_tag_from_resources(mi, tag_key, region)


                def get_tag_request(target):
                    tag_key = check_for_key(target, "Key")

                    request = {
                        "Filters": [
                            {"Key": "AWS:Tag.Key", "Values": [tag_key], "Type": "Equal"}
                        ]
                    }
                    # For the case where only a tag-key is targeted.
                    if "Value" in target:
                        tag_value = check_for_key(target, "Value")
                        request["Filters"].append(
                            {"Key": "AWS:Tag.Value", "Values": [tag_value], "Type": "Equal"}
                        )

                    return request


                def get_resource_group_request(target):
                    # for resource groups, the name is the Target key. e.g. '"Target": {"Key": "ResourceGroupName"}:
                    resource_group_name = check_for_key(target, "Key")
                    request = {
                        "Filters": [
                            {
                                "Key": "AWS:ResourceGroup.Name",
                                "Values": [resource_group_name],
                                "Type": "Equal",
                            }
                        ]
                    }
                    return request


                def get_instance_ids_request(target):
                    request = {"Filters": []}

                    instance_ids = check_for_key(target, "Key").split(",")
                    for ids in range(0, len(instance_ids), 40):
                        request["Filters"].append(
                            {
                                "Key": "AWS:InstanceInformation.InstanceId",
                                "Values": instance_ids[ids : ids + 40],
                                "Type": "Equal",
                            }
                        )
                    return request


                def check_for_key(hashmap, key):
                    if not key in hashmap:
                        raise Exception("The required key %s is not present. Failing." % (key))
                    else:
                        # return the value
                        return hashmap[key]


                def get_target_request(target_type, target):
                    if target_type.lower() == "tags":
                        return get_tag_request(target)

                    elif target_type.lower() == "instanceids":
                        return get_instance_ids_request(target)

                    elif target_type.lower() == "resourcegroups":
                        return get_resource_group_request(target)

                    raise Exception(
                        "Unable to understand the target type of the Patch Policy. Received values was: %s. Failing remediation document. "
                        % (target_type)
                    )


                def begin_remediation(event, context):
                    # Get all variables
                    target_type = check_for_key(event, "TargetType")

                    if target_type == "*":
                        return

                    name_key = check_for_key(event, "NameKey")

                    name_value = check_for_key(event, "NameValue")
                    region = check_for_key(event, "Region")

                    ## Add exception (to make it more robust)
                    target_dict = check_for_key(event, "Targets")

                    target = json.loads(target_dict)

                    # This filter will return all targets of the Patch Policy.
                    request = get_target_request(target_type, target)
                    target_instances = get_inventory(request, region)

                    # This will return targets that have the name tag
                    new_request = {
                        "Filters": [
                            {"Key": "AWS:Tag.Key", "Values": [name_key], "Type": "Equal"},
                            {
                                "Key": "AWS:InstanceInformation.InstanceStatus",
                                "Values": ["Terminated", "ConnectionLost"],
                                "Type": "NotEqual",
                            },
                        ]
                    }

                    named_instances = get_inventory(new_request, region)

                    # 'get instances that are NOT a target of the Patch Policy but have the name tag'
                    instances_to_remove = set(named_instances) - set(target_instances)

                    # remove the tags
                    remove_tags(instances_to_remove, name_key, name_value, region)
            outputs:
              - Name: existingInstanceProfileRoleName
                Selector: "$.Payload.RoleName"
                Type: String
            isEnd: true
      DocumentType: Automation
      Name:
        Fn::Sub: AWSQuickSetup-NameTagRemediation-${QSConfigurationId}

  AddRemoveNameTagAutomationDocument:
    Type: AWS::SSM::Document
    Properties:
      Content:
        description: Quick Setup document for remediating the name tag on EC2 instances.
        schemaVersion: "0.3"
        assumeRole: "{{AutomationAssumeRole}}"
        parameters:
          AutomationAssumeRole:
            type: String
          InstanceId:
            type: String
          QSConfigurationName:
            type: String
          QSConfigurationId:
            type: String
          TagAction:
            type: String
            allowedValues:
              - Add
              - Remove
        mainSteps:
          - name: branchOnInstanceType
            action: aws:branch
            inputs:
              Choices:
                - NextStep: branchOnActionEC2
                  Variable: "{{InstanceId}}"
                  StartsWith: i-
                - NextStep: branchOnActionHybrid
                  Variable: "{{InstanceId}}"
                  StartsWith: mi-
            isEnd: true
          - name: branchOnActionEC2
            action: aws:branch
            inputs:
              Choices:
                - NextStep: removeTagFromEC2Node
                  Variable: "{{TagAction}}"
                  StringEquals: Remove
                - NextStep: addTagToEC2Node
                  Variable: "{{TagAction}}"
                  StringEquals: Add
          - name: removeTagFromEC2Node
            action: aws:executeAwsApi
            inputs:
              Service: ec2
              Api: DeleteTags
              Resources:
                - "{{InstanceId}}"
              Tags:
                - Key: QSConfigName-{{QSConfigurationId}}
            onFailure: Abort
            isEnd: true
          - name: addTagToEC2Node
            action: aws:executeAwsApi
            inputs:
              Service: ec2
              Api: CreateTags
              Resources:
                - "{{InstanceId}}"
              Tags:
                - Key: QSConfigName-{{QSConfigurationId}}
                  Value: "{{QSConfigurationName}}"
            onFailure: Abort
            isEnd: true
          - name: branchOnActionHybrid
            action: aws:branch
            inputs:
              Choices:
                - NextStep: removeTagFromHybridNode
                  Variable: "{{TagAction}}"
                  StartsWith: Remove
                - NextStep: addTagToHybridNode
                  Variable: "{{TagAction}}"
                  StringEquals: Add
          - name: removeTagFromHybridNode
            action: aws:executeAwsApi
            inputs:
              Service: ssm
              Api: RemoveTagsFromResource
              ResourceType: ManagedInstance
              ResourceId: "{{InstanceId}}"
              TagKeys:
                - QSConfigName-{{QSConfigurationId}}
            onFailure: Abort
            isEnd: true
          - name: addTagToHybridNode
            action: aws:executeAwsApi
            inputs:
              Service: ssm
              Api: AddTagsToResource
              ResourceType: ManagedInstance
              ResourceId: "{{InstanceId}}"
              Tags:
                - Key: QSConfigName-{{QSConfigurationId}}
                  Value: "{{QSConfigurationName}}"
            onFailure: Abort
            isEnd: true
      DocumentType: Automation
      Name:
        Fn::Sub: AWSQuickSetup-AddOrRemoveTag-PatchPolicy-${QSConfigurationId}
      TargetType: "/"

  CreateAndAttachIAMToHybridInstanceDocument:
    Type: AWS::SSM::Document
    Properties:
      Content:
        description:
          Composite document for Quick Setup IAM Management of hybrid instances.
          This document ensures IAM role for instance profile is created in account
          with all required policies for Hybrid nodes.
        schemaVersion: "0.3"
        assumeRole: "{{AutomationAssumeRole}}"
        parameters:
          AutomationAssumeRole:
            type: String
          InstanceId:
            type: String
          IsPolicyAttachAllowed:
            type: String
          AwsAccountId:
            type: String
          QSConfigurationId:
            type: String
          Region:
            type: String
        mainSteps:
          - name: branchOnInstanceType
            action: aws:branch
            inputs:
              Choices:
                - NextStep: getExistingRoleName
                  Variable: "{{InstanceId}}"
                  StartsWith: mi-
            isEnd: true
          - name: getExistingRoleName
            action: aws:executeScript
            inputs:
              Runtime: python3.8
              Handler: getRoleName
              InputPayload:
                InstanceId: "{{InstanceId}}"
                Region: "{{Region}}"
              Script: |
                import boto3


                def getRoleName(events, context):
                    region = events["Region"]
                    ssm_client = boto3.client("ssm", region)

                    response = ssm_client.describe_instance_information(
                        InstanceInformationFilterList=[
                            {
                                "key": "InstanceIds",
                                "valueSet": [
                                    events["InstanceId"],
                                ],
                            },
                        ]
                    )

                    if (
                        len(response["InstanceInformationList"]) > 0
                        and "IamRole" in response["InstanceInformationList"][0]
                    ):
                        return {"RoleName": response["InstanceInformationList"][0]["IamRole"]}

                    return {"RoleName": "NoRoleFound"}
            outputs:
              - Name: roleName
                Selector: "$.Payload.RoleName"
                Type: String
            nextStep: branchIfProfileExists
          - name: branchIfProfileExists
            action: aws:branch
            inputs:
              Choices:
                - NextStep: createRoleIfNotExists
                  Variable: "{{getExistingRoleName.roleName}}"
                  StringEquals: NoRoleFound
              Default: checkIfPolicyAttachAllowed
          - name: checkIfPolicyAttachAllowed
            action: aws:branch
            inputs:
              Choices:
                - NextStep: createBaselineOverridePolicyForExistingRole
                  Variable: "{{IsPolicyAttachAllowed}}"
                  StringEquals: "true"
              Default: createRoleIfNotExists
          - name: createBaselineOverridePolicyForExistingRole
            action: aws:executeScript
            inputs:
              Runtime: python3.8
              Handler: createBaselineOverridePolicy
              InputPayload:
                PolicyDocument:
                  Fn::Sub:
                    '{"Version": "2012-10-17","Statement": [{"Effect": "Allow","Action":
                    "s3:GetObject","Resource": "arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-*"}]}'
                Path: "/ssm/quicksetup/patchpolicy/"
                PolicyName: aws-quicksetup-patchpolicy-baselineoverrides-s3
              Script: |
                import boto3
                from botocore.exceptions import ClientError

                iam_client = boto3.client("iam")


                def createBaselineOverridePolicy(events, context):
                    try:
                        policy_name = events["PolicyName"]
                        iam_client.create_policy(
                            PolicyName=policy_name,
                            PolicyDocument=events["PolicyDocument"],
                            Path=events["Path"],
                        )

                    except ClientError as e:
                        if e.response["Error"]["Code"] == "EntityAlreadyExists":
                            print("Policy already exists. Skipping creation.")
                        else:
                            raise e
            onFailure: Abort
            description:
              Create the S3 Bucket Policy. If exception and EntityAlreadyExists,
              continue, else Abort.
            nextStep: attachBaselineOverridePolicyToExistingRole
          - name: attachBaselineOverridePolicyToExistingRole
            action: aws:executeAwsApi
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: "{{getExistingRoleName.roleName}}"
              PolicyArn:
                Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/ssm/quicksetup/patchpolicy/aws-quicksetup-patchpolicy-baselineoverrides-s3
            description: Attach required managed policy to Instance Profile role.
            nextStep: attachAmazonSSMManagedInstanceCoreToExistingRole
            onFailure: Abort
          - name: attachAmazonSSMManagedInstanceCoreToExistingRole
            action: aws:executeAwsApi
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: "{{getExistingRoleName.roleName}}"
              PolicyArn:
                Fn::Sub: arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
            nextStep: attachTagToExistingRole
          - name: attachTagToExistingRole
            action: aws:executeAwsApi
            inputs:
              Service: iam
              Api: TagRole
              RoleName: "{{getExistingRoleName.roleName}}"
              Tags:
                - Key:
                    Fn::Sub: QSConfigId-${QSConfigurationId}
                  Value:
                    Fn::Sub: "${QSConfigurationId}"
            isEnd: true
          - name: createRoleIfNotExists
            action: aws:executeScript
            inputs:
              Runtime: python3.8
              Handler: createRoleIfNotExists
              InputPayload:
                Path: "/"
                RoleName: AmazonSSMRoleForInstancesQuickSetup
                AssumeRolePolicyDocument: '{"Version":"2012-10-17","Statement":[{"Effect":"Allow","Principal":{"Service":"ssm.amazonaws.com"},"Action":"sts:AssumeRole"}]}'
                Description: SSM Hybrid role for SSM for Quick-Setup
              Script: |
                import boto3
                from botocore.exceptions import ClientError

                iam_client = boto3.client("iam")


                def createRoleIfNotExists(events, context):
                    try:
                        iam_client.create_role(
                            Path=events["Path"],
                            RoleName=events["RoleName"],
                            AssumeRolePolicyDocument=events["AssumeRolePolicyDocument"],
                            Description=events["Description"],
                        )

                    except ClientError as e:
                        if e.response["Error"]["Code"] == "EntityAlreadyExists":
                            print("Role already exists. Skipping creation.")
                        else:
                            raise e
            onFailure: Abort
            description:
              Create AmazonSSMRoleForInstancesQuickSetup Role For SSM Quick
              Setup
            nextStep: assertRoleExists
          - name: assertRoleExists
            action: aws:assertAwsResourceProperty
            inputs:
              Service: iam
              Api: GetRole
              PropertySelector: "$.Role.RoleName"
              DesiredValues:
                - AmazonSSMRoleForInstancesQuickSetup
              RoleName: AmazonSSMRoleForInstancesQuickSetup
            nextStep: createBaselineOverridePolicy
          - name: createBaselineOverridePolicy
            action: aws:executeScript
            inputs:
              Runtime: python3.8
              Handler: createBaselineOverridePolicy
              InputPayload:
                PolicyDocument:
                  Fn::Sub:
                    '{"Version": "2012-10-17","Statement": [{"Effect": "Allow","Action":
                    "s3:GetObject","Resource": "arn:${AWS::Partition}:s3:::aws-quicksetup-patchpolicy-*"}]}'
                Path: "/ssm/quicksetup/patchpolicy/"
                PolicyName: aws-quicksetup-patchpolicy-baselineoverrides-s3
              Script: |
                import boto3
                from botocore.exceptions import ClientError

                iam_client = boto3.client("iam")


                def createBaselineOverridePolicy(events, context):
                    try:
                        policy_name = events["PolicyName"]
                        iam_client.create_policy(
                            PolicyName=policy_name,
                            PolicyDocument=events["PolicyDocument"],
                            Path=events["Path"],
                        )

                    except ClientError as e:
                        if e.response["Error"]["Code"] == "EntityAlreadyExists":
                            print("Policy already exists. Skipping creation.")
                        else:
                            raise e
            onFailure: Abort
            description:
              Create the S3 Bucket Policy. If exception and EntityAlreadyExists,
              continue, else Abort.
            nextStep: attachBaselineOverridePolicyToRole
          - name: attachBaselineOverridePolicyToRole
            action: aws:executeAwsApi
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: AmazonSSMRoleForInstancesQuickSetup
              PolicyArn:
                Fn::Sub: arn:${AWS::Partition}:iam::${AWS::AccountId}:policy/ssm/quicksetup/patchpolicy/aws-quicksetup-patchpolicy-baselineoverrides-s3
            description: Attach required managed policy to Instance Profile role.
            nextStep: attachAmazonSSMManagedInstanceCoreToRole
            onFailure: Abort
          - name: attachAmazonSSMManagedInstanceCoreToRole
            action: aws:executeAwsApi
            inputs:
              Service: iam
              Api: AttachRolePolicy
              RoleName: AmazonSSMRoleForInstancesQuickSetup
              PolicyArn:
                Fn::Sub: arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
            nextStep: attachTagToRole
          - name: attachTagToRole
            action: aws:executeAwsApi
            inputs:
              Service: iam
              Api: TagRole
              RoleName: AmazonSSMRoleForInstancesQuickSetup
              Tags:
                - Key:
                    Fn::Sub: QSConfigId-${QSConfigurationId}
                  Value:
                    Fn::Sub: "${QSConfigurationId}"
            nextStep: attachRoleToInstance
          - name: attachRoleToInstance
            action: aws:executeScript
            inputs:
              Runtime: python3.8
              Handler: addRoleToHybridInstance
              InputPayload:
                RoleName: AmazonSSMRoleForInstancesQuickSetup
                InstanceId: "{{InstanceId}}"
                Region: "{{Region}}"
              Script: |
                import boto3
                from botocore.exceptions import ClientError


                def addRoleToHybridInstance(events, context):
                    try:
                        ssm_client = boto3.client("ssm", region_name=events["Region"])
                        ssm_client.update_managed_instance_role(
                            InstanceId=events["InstanceId"], IamRole=events["RoleName"]
                        )

                    except ClientError as e:
                        raise e
            onFailure: Abort
            description:
              Add AmazonSSMRoleForInstancesQuickSetup Role to the hybrid
              (mi-) instance.
            isEnd: true
      DocumentType: Automation
      Name:
        Fn::Sub: AWSQuickSetup-CreateAndAttachIAMToHybridNode-${QSConfigurationId}
      TargetType: "/AWS::SSM::ManagedInstance"
    DependsOn: RoleForAutomation
